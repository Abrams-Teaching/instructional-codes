/* 
   Metropolis Monte Carlo simulation of 2D hard dumbbells confined in a circle

   Cameron F. Abrams

   Written for the course CHE T580 Modern Molecular Simulation
   Spring 20-21

   compile using "gcc -o hdb hdb.c -lm -lgsl"

   runs as "./hdisk -N <number_of_particles> -rho <density> \
                    -R <radius_of_circle> \
                    -nc <numcycles(1e6)>  \
		    -s <seed(?)> \
		    -dw <weight_of_displacement_trial_move(0.5)> \
		    -dr <max_displacement(1.0)> \
		    -da <max_angle_rotation(pi/2)> \
		    -r_0 <dumbbell bond-length(1.0)> \
		    -s <particle_diameter(1.0)>"

   You must have the GNU Scientific Library installed; see
   the coursenotes to learn how to do this.

   Drexel University, Department of Chemical Engineering
   Philadelphia
   (c) 2004-2021
*/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <gsl/gsl_rng.h>

/* writes configuration in a custom format that can be read by fig2dev to generate
   a graphic. */
void out_fig ( FILE * fp, double * rx, double * ry, int n, double R2 ) {
  int i;
  double R = sqrt(R2);
  int iR = (int)(R*300);
  fprintf(fp,"#FIG 3.2\n" "Landscape\n" "Center\n" "Inches\n" "Letter\n"
	  "100.00\n" "Single\n" "-2\n" "1200 2\n");
  fprintf(fp,"1 3 0 1 0 7 50 -1 -1 0.000 1 0.0000 %i %i %i %i %i %i %i %i\n",iR,iR,iR,iR,iR,iR,2*iR,iR);
  for (i=0;i<n;i++) {
    int x = (int)((rx[i] + R)*300);
    int y = (int)((ry[i] + R)*300);
    fprintf(fp,"1 3 0 1 0 7 50 -1 -1 0.000 1 0.0000 %i %i "
	    "150 150 %i %i %i %i\n",x,y,x,y,x+150,y);
    if (!(i%2)) {
      int x2 = (int)((rx[i+1] + R)*300);
      int y2 = (int)((ry[i+1] + R)*300);
      fprintf(fp,"2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2\n"
			"%i %i %i %i\n",x,y,x2,y2);
    }
  }
}

/* Writes configuration in XYZ format */
void write_xyz(FILE * fp, double * rx, double * ry, int n) {
  int i;
  fprintf(fp,"%i\n",n);
  fprintf(fp,"Generated by hdisk-dumbbells.c; all z-components are zero; all elements are Ar\n");
  for (i=0;i<n;i++) {
    fprintf(fp,"Ar %.5lf %.5lf 0.00000\n",rx[i],ry[i]);
  }
}

/* randomly places dimer at positions 0 and 1 in the dx,dy arrays within a circle of
   radius R centered on the origin.  Dimer bondlength is l. */
void random_place_dimer ( double * dx, double * dy, double R, double l, gsl_rng * r ) {
    double cr,ct,cx,cy,ra;
    cr=(R-l/2)*gsl_rng_uniform(r);
    ct=2*M_PI*gsl_rng_uniform(r);
    cx=cr*cos(ct);
    cy=cr*sin(ct);
    ra=M_PI*gsl_rng_uniform(r);
    dx[0]=cx+l/2*cos(ra);
    dy[0]=cy+l/2*sin(ra);
    dx[1]=cx-l/2*cos(ra);
    dy[1]=cy-l/2*sin(ra);
}

/* Detects steric clash between dimer at n,n+1 and all dimers
   prior to that in rx, ry.  s2 is the square of the monomer diameter. */
int clash_detector ( double * rx, double * ry, double s2, int n ) {
  int j;
  double sx, sy, r2;
  double clash_found=0;
  for (j=0;j<n;j++) {
    sx  = rx[n]-rx[j];
    sy  = ry[n]-ry[j];
    r2  = sx*sx + sy*sy;
    if (r2 < s2) {
      clash_found=1;
      break;
    }
    sx  = rx[n+1]-rx[j];
    sy  = ry[n+1]-ry[j];
    r2  = sx*sx + sy*sy;
    if (r2 < s2) {
      clash_found=1;
      break;
    }
  }
  return clash_found;
}

/* Initialize dumbbell positions by assigning them
   randomly while avoiding overlaps. */
void init ( double * rx, double * ry, 
	    int n, double R2, double s2, double r_02, gsl_rng * r) {
  int i;
  double R = sqrt(R2), l = sqrt(r_02);
  /* nMax is a maximum number of insertion trials */
  int nMax = 50000, nTrials=0;

  for (i=0;i<n;i+=2) {
    nTrials = 0;
    random_place_dimer(&rx[i],&ry[i],R,l,r);
    while (clash_detector(rx,ry,s2,i) && nTrials<nMax) {
      random_place_dimer(&rx[i],&ry[i],R,l,r);
      nTrials++;
    }
    if (nTrials==nMax) {
      fprintf(stderr,"# Error -- could not initialize position "
	      "of particle %i in %i trials\n",i,nTrials);
      fprintf(stderr,"# program ends.\n");
      exit(-1);
    }
  }
}

/* Sanity-checker to make sure I don't screw up and bond lengths */
void bond_length_checker(int c, double * rx, double * ry, double r_02, int N) {
  int i, j;
  double dx2, dy2, d;
  for (j=0;j<N/2;j++) {
    i=j*2;
    dx2=pow(rx[i]-rx[i+1],2);
    dy2=pow(ry[i]-ry[i+1],2);
    d=dx2+dy2;
    if (fabs(d-r_02)>1.e-3) {
      fprintf(stdout,"Cycle-%i Warning: dimer %i (%i-%i) has a weird bond length %.5lf.\n",c,i,j,j+1,sqrt(d));
    }
  }
}

enum { DISP, ROTATE };
enum { XYZ, FIG, NONE };

int main ( int argc, char * argv[] ) {

  double * rx, * ry;
  int N=-1,c,a;
  double R2=16.0, s2=1.0, r_02=1.0, dA, cs, sn, xc, yc;
  double rho=0.5;
  double xs[2], ys[2], disp_wt = 0.5;
  double dr=0.1,dx,dy,theta,sx,sy,r2, da=M_PI/2, nx,ny;
  int i,j,k;
  int nCycles = 10;
  int reject;
  int nDispAttempt, nRotAttempt, nDispAcc, nRotAcc;
  int noob=0,novl=0, move;
  int fSamp=1000;
  int traj_out = NONE;
  char *traj_fn,tmp_fn[25];

  FILE * tmp_fp;

  gsl_rng * r = gsl_rng_alloc(gsl_rng_mt19937);
  unsigned long int Seed = 23410981;

  /* Here we parse the command line arguments */
  for (i=1;i<argc;i++) {
    if (!strcmp(argv[i],"-N"))        N       = atoi(argv[++i]);
    else if (!strcmp(argv[i],"-R"))   R2      = atof(argv[++i]);
    else if (!strcmp(argv[i],"-rho")) rho     = atof(argv[++i]);
    else if (!strcmp(argv[i],"-dr"))  dr      = atof(argv[++i]);
    else if (!strcmp(argv[i],"-da"))  da      = atof(argv[++i]);
    else if (!strcmp(argv[i],"-sig")) s2      = atof(argv[++i]);
    else if (!strcmp(argv[i],"-r_0")) r_02    = atof(argv[++i]);
    else if (!strcmp(argv[i],"-dw"))  disp_wt = atof(argv[++i]);
    else if (!strcmp(argv[i],"-nc"))  nCycles = atoi(argv[++i]);
    else if (!strcmp(argv[i],"-fs"))  fSamp   = atoi(argv[++i]);
    else if (!strcmp(argv[i],"-traj"))  {
      traj_fn=argv[++i];
      /* detect format */
      if (strstr(traj_fn, ".xyz") != NULL) {
        traj_out=XYZ;
      } else if (strstr(traj_fn, ".fig") != NULL) {
        traj_out=FIG;
      } else {
        fprintf(stdout,"File format of %s not recognized; must by xyz or fig.\n",traj_fn);
        traj_out=NONE;
      }
    }
    else if (!strcmp(argv[i],"-s"))   Seed    = (unsigned long)atoi(argv[++i]);
  }

  /* Some checks */
  if (disp_wt < 0.0 || disp_wt > 1.0) {
    fprintf(stderr,"# Error: please select a displacement weight between 0 and 1\n");
    exit(-1);
  }

  s2=s2*s2;
  r_02=r_02*r_02;

  /* If N was not set by the user, calculate it based on 
     the given values of density and radius */
  if (N==-1) {
    N = (int)(rho*M_PI*R2);
    if (N%2) N--;
  }
  /* Otherwise, recompute the radius. */
  else {
    if (N%2) N--;
    R2 = ((double)N)/rho/M_PI;
  }

  fprintf(stdout,"# R = %.2lf; rho = %.2lf; N = %i; r_0 = %.2lf; s = %.2lf; disp_wt = %.2lf, seed = %lu\n",
	  sqrt(R2),rho,N,sqrt(r_02),sqrt(s2),disp_wt,Seed);

  /* Seed the random number generator */
  gsl_rng_set(r,Seed);

  /* allocate the position arrays */
  rx = (double*)malloc(N*sizeof(double));
  ry = (double*)malloc(N*sizeof(double));

  /* generate initial positions that fit inside 
     circle with radius R and guarantee no 
     particles overlap. */
  init(rx,ry,N,R2,s2,r_02,r);
  bond_length_checker(0,rx,ry,r_02,N);
  if (traj_out==FIG) {
    sprintf(tmp_fn,"%05i-%s",0,traj_fn);
    tmp_fp=fopen(tmp_fn,"w");
    out_fig(tmp_fp,rx,ry,N,R2);
    fclose(tmp_fp);
  } else if (traj_out==XYZ) {
    tmp_fp=fopen(traj_fn,"w");
    write_xyz(tmp_fp,rx,ry,N);
    fclose(tmp_fp);
  }

  nDispAcc = nRotAcc = 0;
  nDispAttempt = nRotAttempt = 0;
  for (c=0;c<nCycles;c++) {
    /* Make N attempts */
    for (a=0;a<N;a++) {
      /* randomly select a molecule */
      i=(int)gsl_rng_uniform_int(r,N/2);
      i*=2;  /* N is assumed even */
      /* save its position */
      for (k=0;k<2;k++) {
        xs[k] = rx[i+k];
        ys[k] = ry[i+k];
      }
      /* decide whether to move this molecule, or to rotate it. */
      if (gsl_rng_uniform(r) < disp_wt) {
        move = DISP;
        /* calc displacement */
        dx = dr*(0.5-gsl_rng_uniform(r));
        dy = dr*(0.5-gsl_rng_uniform(r));
        /* displace molecule */
        for (k=0;k<2;k++) {
          rx[i+k]+=dx;
          ry[i+k]+=dy;
        }
        nDispAttempt++;
      }
      else {
        move = ROTATE;
        /* compute random angle */
        dA = da*(0.5-gsl_rng_uniform(r));
        cs=cos(dA);
        sn=sin(dA);
        /* translate COM to origin (convert to internal coords) */
        xc=0.5*(rx[i]+rx[i+1]);
        yc=0.5*(ry[i]+ry[i+1]);
        for (k=0;k<2;k++) {
          rx[i+k]-=xc;
          ry[i+k]-=yc;
        }
        /* rotate and transform back to global coords*/
        for (k=0;k<2;k++) {
          nx  = rx[i+k]*cs - ry[i+k]*sn;
          ny  = rx[i+k]*sn + ry[i+k]*cs;
          rx[i+k] = nx+xc;
          ry[i+k] = ny+yc;
        }
        nRotAttempt++;
      }

      /* Determine whether we should reject this move */
      /* First, check to make sure molecule stays inside circle */
      reject=0;
      for (k=0;!reject&&k<2;k++) {
        /* compute new distance to origin */
        r2=rx[i+k]*rx[i+k]+ry[i+k]*ry[i+k];
        /* reject move if outside circle */
        reject=(r2>R2);
        if (reject) noob++;
      }

      /* Second, check for overlaps with other particles */
      for (j=0;(!reject)&&(j<N);j++) {
        if (j!=i&&j!=(i+1)) {
          sx  = rx[i]-rx[j];
          sy  = ry[i]-ry[j];
          r2  = sx*sx + sy*sy;
          reject = r2<s2;
          /* check the partner */
          if (!reject) {
            sx  = rx[i+1]-rx[j];
            sy  = ry[i+1]-ry[j];
            r2  = sx*sx + sy*sy;
            reject = r2<s2;
          }
        }
        if (reject) novl++;
      }

      /* if move is rejected, undo trial move */
      if (reject) {
        for (k=0;k<2;k++) {
          rx[i+k]=xs[k];
          ry[i+k]=ys[k];
        }
      }
      else {
        if (move == DISP) nDispAcc++;
        else if (move == ROTATE) nRotAcc++;
      }
    }
    if (!(c%fSamp)) {
      if (traj_out==FIG) {
          sprintf(tmp_fn,"%05i-%s",c,traj_fn);
          tmp_fp=fopen(tmp_fn,"w");
          out_fig(tmp_fp,rx,ry,N,R2);
          fclose(tmp_fp);
      } else if (traj_out==XYZ) {
          tmp_fp=fopen(traj_fn,"a");
          write_xyz(tmp_fp,rx,ry,N);
          fclose(tmp_fp);
      }
    }
  }

  fprintf(stdout,"Results:\n"
	  "Number of trial moves:             %i\n"
	  "Maximum displacement length:       %.3lf\n"
	  "Number of displacement attempts:   %i\n"
	  "Maximum rotation angle (radians):  %.3lf\n"
	  "Number of rotation attempts:       %i\n"
	  "Displacement acceptance ratio:     %.3lf\n"
	  "Rotation acceptance ratio:         %.3lf\n"
	  "Reject Fraction Out-of-bounds:     %.5lf\n"
	  "Reject Fraction Overlap:           %.5lf\n",
	  N*nCycles,dr,nDispAttempt,da,nRotAttempt,
	  nDispAttempt?((double)nDispAcc)/nDispAttempt:0,
	  nRotAttempt?((double)nRotAcc)/nRotAttempt:0,
	  ((double)noob)/(N*nCycles-nRotAcc-nDispAcc),
	  ((double)novl)/(N*nCycles-nRotAcc-nDispAcc)
	  );
  if (traj_out!=NONE) {
    fprintf(stdout,"Trajectory saved to:               %s\n",traj_fn);
  }
}

